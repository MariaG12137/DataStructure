function Queue(){
  let items = [];
 
  this.enqueue = function(element){
    items.push(element);
  }
 
  this.dequeue = function(){
    return items.shift();
  }
  
  this.front = function(){
    return items[0];
  }
 
  this.isEmpty = function(){
    return items.length == [];
  }
 
  this.size = function(){
    return items.length;
  }
 
  this.print = function(){
    console.log(items.toString())
  }
 
}
//Create a graph
function Dictionary(){
  let items = {};

  this.has = function(key){
    return key in items;
  };

  this.set = function(key, value){
    items[key] = value;
  };

  this.delete = function(key){
    if(this.has(key)){
      delete items[key];
      return true;
    }
    return false;
  };

  this.get = function(key){
    return this.has(key) ? items[key]: undefined;
  };

  this.values = function(){
    let values = [];
    for (let key in items){
      values.push(this.get(key));
    }
    return values;
  };

  this.clear = function(){
    items = {};
  };

  this.size = function(){
    return Object.keys(items).length;
  };

  this.keys = function(){
    return Object.keys(items);
  };

  this.getItems = function(){
    return items;
  }
}

//Create a graph

function Graph(){
  let vertices = [];
  let adjList = new Dictionary();

  this.addVertex = function(v){
    vertices.push(v);
    adjList.set(v, []);
  };

  this.addEdge = function(v, w){
    adjList.get(v).push(w);
    adjList.get(w).push(v);
  }

  this.toString = function(){
    var s = '';
    for(let ver of vertices){
      s += ver + '->';
      let neighbors = adjList.get(ver);
      for(let nei of neighbors){
        s += nei + ' ';
      }
      s += '\n';
    }
    return s;
  };

  let initializeColor = function(){
    let color = [];
    for (let i=0; i<vertices.length; i++){
      color[vertices[i]] = 'white';
    }
    return color;
  };
  
  this.bfs = function(v,callback){
    let color = initializeColor();
    queue = new Queue();
    queue.enqueue(v);

    while (!queue.isEmpty()){
      let u = queue.dequeue();
      neighbors = adjList.get(u);
      color[u] = 'grey';
      for(let nei of neighbors){
        var w = nei;
        if(color[w] === 'white'){
          color[w] = 'grey';
          queue.enqueue(w);
        }
      }
      color[u] = 'black';
      if(callback){
        callback(u);
      }
    }
  };

  this.BFS = function(v){

    let color = initializeColor();
    let queue = new Queue();
    let d = {};
    let pred = {};
    queue.enqueue(v);

    for(let ver of vertices){
      d[ver] = 0;
      pred[ver] = null;
    }

    while(!queue.isEmpty()){
      let u = queue.dequeue();
      neighbors = adjList.get(u);
      color[u] = 'grey';

      for(let nei of neighbors){
        let w = nei;
        if(color[w] === 'white'){
          color[w] = 'grey';
          d[w] = d[u]+1;
          pred[w] = u;
          queue.enqueue(w);
        }
      }
      color[u] = 'black';
    }
    return console.log(d,pred);
  };

}
let graph = new Graph();
let myVertices = ['A','B','C','D','E','F','G','H','I'];
for(let ver of myVertices){
  graph.addVertex(ver);
}
graph.addEdge('A','B');
graph.addEdge('A','C');
graph.addEdge('A','D');
graph.addEdge('C','D');
graph.addEdge('C','G');
graph.addEdge('D','G');
graph.addEdge('D','H');
graph.addEdge('B','E');
graph.addEdge('B','F');
graph.addEdge('E','I');
console.log(graph.toString());

function printNode(value){
  console.log('Visited vertex: ' + value);
};

graph.bfs(myVertices[0], printNode);

let shortestPathA = graph.BFS(myVertices[0]);
